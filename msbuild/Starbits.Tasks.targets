<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  
  <Import Project="$(MSBuildThisFileDirectory)Starbits.Base.props" />
  
  <UsingTask TaskName="CombinePackageConfigs" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <PackageConfigFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <OutputPath ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Xml" />
      <Reference Include="System.Xml.Linq" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Xml" />
      <Using Namespace="System.Xml.Linq" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        var packages = 
          PackageConfigFiles.AsParallel()
                            .Where(x => File.Exists(x.GetMetadata("FullPath")))
                            .Select(x => XDocument.Load(x.GetMetadata("FullPath")))
                            .SelectMany(x => x.Root.Elements("package"))
                            .Select(x => new { Id = x.Attribute("id").Value, Version = x.Attribute("version").Value })
                            .Distinct()
                            .OrderBy(x => x.Id);
        
        var document =
            new XDocument(
                new XDeclaration("1.0", "utf-8", "true"),
                new XElement("packages", 
                    packages.Select(x => new XElement("package", new XAttribute("id", x.Id), new XAttribute("version", x.Version)))));

        document.Save(OutputPath);
        ]]>
      </Code>
    </Task>
  </UsingTask>
  
  <!--
  Gets the latest installed version of a package. Based on "nuget list".
  Usage:
    <GetLatestNuGetPackageVersion Package="Starcounter">
      <Output PropertyName="LatestStarcounterPackageVersion" TaskParameter="PackageVersion"/>
    </GetLatestNuGetPackageVersion>
    
  Remarks: currently use $(StarcounterMyGetFeed) as the source, since this is what we need in
  Starbits. Factor that out as a parameter for a more general purpose target.
  -->
  <UsingTask TaskName="GetLatestNuGetPackageVersion" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <!-- The package to be queried and the output version -->
      <Package ParameterType="System.String" Required="true" />
      <PackageVersion ParameterType="System.String" Output="true" />
      <NuGetExeCommand ParameterType="System.String" Required="true"/>    
      <!-- Considered future parameters -->
      <!--  1) Specify sources
            2) Exclude pre-release
            3) Path to config
            -->
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Diagnostics" />
      <Using Namespace="System.Collections.Generic"/>
      <Using Namespace="System.IO" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        string version;
        var nugetPath = NuGetExeCommand;
        nugetPath = nugetPath.Trim('"');
        var sources = "$(StarcounterMyGetFeed)";
        
        Environment.CurrentDirectory = Path.GetDirectoryName(nugetPath);
        var output = new List<string>(3);
        PackageVersion = string.Empty;
        
        var start = new ProcessStartInfo(nugetPath, string.Format("list {0} -Prerelease -Source {1}", Package, sources)) {
            ErrorDialog = false,
            UseShellExecute = false,
            CreateNoWindow = true,
            RedirectStandardOutput = true
        };

        var p = new Process() { StartInfo = start };
        p.OutputDataReceived += (sender, e) => { output.Add(e.Data); };

        Log.LogMessage(p.StartInfo.FileName + " " + p.StartInfo.Arguments, MessageImportance.Low);
        p.Start();
        p.BeginOutputReadLine();
        if (!p.HasExited) { 
            p.WaitForExit(); 
        }
        if (p.ExitCode != 0) {
            Log.LogMessage(string.Format("NuGet.exe exited with error {0}.", p.ExitCode), MessageImportance.High);
            return false;
        }

        // If not exactly one non-empty line is in the output, this
        // task is considered failed.

        version = string.Empty;
        foreach (var listed in output) {
            if (!string.IsNullOrWhiteSpace(listed)) {
                if (version != string.Empty) {
                    Log.LogMessage("Output of NuGet.exe 'list' didn't meet the expected format:", MessageImportance.High);
                    for (int i = 0; i < output.Count; i++) {
                      if (i == 5) {
                          Log.LogMessage("More...", MessageImportance.High);
                          break;
                      }
                      
                      var line = output[i] ?? string.Empty;
                      Log.LogMessage(line, MessageImportance.High);
                    }
                    
                    //foreach (var line in output) {
                    //    Log.LogMessage(line ?? string.Empty, MessageImportance.High);
                    //}
                    return false;
                }
                version = listed;
            }
        }
        
        // Keep an eye on upcoming NuGet 2.8 where support for
        // more accurate output parsing of the list command are
        // probably added. See:
        // https://nuget.codeplex.com/workitem/3890

        PackageVersion = version.Substring(version.IndexOf(" ") + 1).Trim();
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>